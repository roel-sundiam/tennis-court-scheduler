import { Component, OnInit, ViewEncapsulation, ChangeDetectorRef } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ActivatedRoute, RouterModule } from '@angular/router';
import { MatCardModule } from '@angular/material/card';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatSelectModule } from '@angular/material/select';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatDividerModule } from '@angular/material/divider';
import { MatChipsModule } from '@angular/material/chips';
import { MatListModule } from '@angular/material/list';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatMenuModule } from '@angular/material/menu';
import { FormsModule } from '@angular/forms';
import { ConfirmDialogComponent } from '../../shared/confirm-dialog.component';
import { Poll, DateOption, Vote } from '../../models/poll.model';
import { PollService } from '../../services/poll.service';
import { PlayersService } from '../../mock-data/players.service';
import { Player } from '../../mock-data/mock-players';
import { CoinService } from '../../services/coin.service';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { Router } from '@angular/router';

// Team generation interfaces
interface Team {
  id: string;
  player1: Player;
  player2: Player;
  averageSeed: number;
}

interface Match {
  id: string;
  teamA: Team;
  teamB: Team;
}

interface GeneratedMatches {
  dateId: string;
  algorithm: string;
  teams: Team[];
  matches: Match[];
  reservePlayers: Player[];
  autoGenerated?: boolean;
}

interface ManualPairingState {
  availablePlayers: Player[];
  selectedPlayers: Player[];
  teams: Team[];
  reservePlayers: Player[];
}

@Component({
  selector: 'app-poll-results',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatCardModule,
    MatProgressSpinnerModule,
    MatToolbarModule,
    MatIconModule,
    MatButtonModule,
    MatDividerModule,
    MatChipsModule,
    MatListModule,
    MatTooltipModule,
    MatDialogModule,
    MatMenuModule,
    FormsModule,
    MatSnackBarModule
  ],
  templateUrl: './poll-results.component.html',
  styleUrls: ['./poll-results.component.scss'],
  encapsulation: ViewEncapsulation.None
})
export class PollResultsComponent implements OnInit {
  poll: Poll | undefined;
  players: Player[] = [];
  loading = false;
  error = '';
  
  // Team generation properties
  generatedMatches: { [dateId: string]: GeneratedMatches } = {};
  selectedAlgorithms: { [dateId: string]: string } = {};
  
  // Manual pairing properties
  manualPairingStates: { [dateId: string]: ManualPairingState } = {};
  
  // View toggle property
  isCompactView = true;
  
  // Coin system
  hasAccess = false;
  coinBalance = 0;
  pageCost = 5;
  
  algorithmOptions = [
    { value: 'random', label: 'Random' },
    { value: 'balanced', label: 'Balanced (Top vs Bottom)' },
    { value: 'grouped', label: 'Skill-Level Groups' },
    { value: 'manual', label: 'Manual Pairing' }
  ];

  constructor(
    private route: ActivatedRoute,
    private pollService: PollService,
    private playersService: PlayersService,
    private cdr: ChangeDetectorRef,
    private dialog: MatDialog,
    public coinService: CoinService,
    private snackBar: MatSnackBar,
    private router: Router
  ) {}

  ngOnInit() {
    this.initializeCoinSystem();
  }

  initializeCoinSystem() {
    // Subscribe to balance changes
    this.coinService.balance$.subscribe(balance => {
      this.coinBalance = balance;
    });

    // Check if user can access the page
    this.checkPageAccess();
  }

  checkPageAccess() {
    if (this.coinService.canAfford('POLL_RESULTS_VIEW')) {
      this.purchasePageAccess();
    } else {
      this.showInsufficientCoinsMessage();
    }
  }

  purchasePageAccess() {
    this.coinService.useCoins('POLL_RESULTS_VIEW', 'Poll Results page access').subscribe({
      next: (success) => {
        if (success) {
          this.hasAccess = true;
          this.loadAllData();
          if (!this.coinService.hasUnlimitedAccess()) {
            this.showSuccessMessage(`Poll Results access granted! (${this.pageCost} coins used)`);
          }
        } else {
          this.showInsufficientCoinsMessage();
        }
      },
      error: (error) => {
        console.error('Failed to purchase poll results access:', error);
        this.showErrorMessage('Failed to process payment. Please try again.');
      }
    });
  }

  loadAllData() {
    this.loadPollResults();
    this.loadPlayers();
    // Load existing teams first, then check for auto-generation
    this.loadGeneratedTeams();
  }

  loadPollResults() {
    const pollId = this.route.snapshot.paramMap.get('id');
    if (!pollId) {
      this.error = 'Invalid poll ID';
      return;
    }

    this.loading = true;
    this.pollService.getPollById(pollId).subscribe({
      next: (poll) => {
        if (poll) {
          this.poll = poll;
          this.loading = false;
        } else {
          this.error = 'Poll not found';
          this.loading = false;
        }
      },
      error: () => {
        this.error = 'Failed to load poll results';
        this.loading = false;
      }
    });
  }

  getSortedDateOptions(): DateOption[] {
    if (!this.poll) return [];
    const sorted = [...this.poll.options].sort((a, b) =>
      new Date(a.date).getTime() - new Date(b.date).getTime()
    );
    return sorted;
  }

  getVotesForOption(optionId: string): Vote[] {
    const option = this.poll?.options.find((opt: DateOption) => opt.id === optionId);
    return option?.votes || [];
  }

  getVoteCount(optionId: string): number {
    return this.getPlayersForDate(optionId).length;
  }

  loadPlayers() {
    this.playersService.getPlayers().subscribe({
      next: (players) => {
        this.players = players;
      },
      error: () => {
        console.error('Failed to load players');
      }
    });
  }

  loadGeneratedTeams() {
    const pollId = this.route.snapshot.paramMap.get('id');
    if (!pollId) return;

    console.log('Loading generated teams for poll:', pollId);
    this.pollService.getGeneratedTeams(pollId).subscribe({
      next: (response) => {
        console.log('ðŸ“¥ Backend response for generated teams:', response);
        const savedTeams = response.generatedTeams || [];
        console.log('ðŸ“Š Saved teams data:', savedTeams);
        
        // Convert saved teams back to the local format
        savedTeams.forEach((teamData: any) => {
          console.log('ðŸ”„ Restoring teams for date:', teamData.dateId);
          this.generatedMatches[teamData.dateId] = {
            dateId: teamData.dateId,
            algorithm: teamData.algorithm,
            teams: teamData.teams,
            matches: teamData.matches,
            reservePlayers: teamData.reservePlayers
          };
          // Also set the selected algorithm for the dropdown
          this.selectedAlgorithms[teamData.dateId] = teamData.algorithm;
        });
        
        console.log('ðŸŽ¯ Final generatedMatches:', this.generatedMatches);
        console.log('ðŸŽ¯ Final selectedAlgorithms:', this.selectedAlgorithms);
        
        // Force change detection to update the UI
        this.cdr.detectChanges();
        console.log('ðŸ”„ Triggered change detection');
        
        // Check for auto-generation after loading existing teams and when players are available
        setTimeout(() => {
          this.checkForAutoGeneration();
        }, 100);
      },
      error: (error) => {
        console.error('âŒ Failed to load generated teams:', error);
      }
    });
  }

  // Get players who voted for a specific date with their full player data
  getPlayersForDate(dateId: string): Player[] {
    if (!this.poll?.votes || !this.players.length) return [];
    
    // Find all votes that include this dateId
    const voterIds = this.poll.votes
      .filter(vote => vote.optionIds?.includes(dateId))
      .map(vote => vote.playerId);
    
    // Get full player data for these voters and sort by seed
    return this.players
      .filter(player => voterIds.includes(player.id))
      .sort((a, b) => a.seed - b.seed); // Sort by seed (1 = best)
  }

  // Generate teams based on selected algorithm
  generateTeams(dateId: string) {
    // Check if user can afford team generation
    if (!this.coinService.canAfford('TEAM_GENERATION')) {
      this.showInsufficientCoinsMessage('generate teams');
      return;
    }

    const algorithm = this.selectedAlgorithms[dateId];
    if (!algorithm) return;

    const players = this.getPlayersForDate(dateId);
    if (players.length < 2) return;

    // Charge coins for team generation
    this.coinService.useCoins('TEAM_GENERATION', `Generate teams for ${dateId} using ${algorithm} algorithm`).subscribe({
      next: (success) => {
        if (success) {
          this.executeTeamGeneration(dateId, algorithm, players);
          if (!this.coinService.hasUnlimitedAccess()) {
            const cost = this.coinService.getFeatureCost('TEAM_GENERATION');
            this.showSuccessMessage(`Teams generated! (${cost} coins used)`);
          }
        } else {
          this.showInsufficientCoinsMessage('generate teams');
        }
      },
      error: (error) => {
        console.error('Failed to charge for team generation:', error);
        this.showErrorMessage('Failed to process payment for team generation.');
      }
    });
  }

  private executeTeamGeneration(dateId: string, algorithm: string, players: Player[]) {

    let teams: Team[] = [];
    let reservePlayers: Player[] = [];

    switch (algorithm) {
      case 'random':
        ({ teams, reservePlayers } = this.generateRandomTeams(players));
        break;
      case 'balanced':
        ({ teams, reservePlayers } = this.generateBalancedTeams(players));
        break;
      case 'grouped':
        ({ teams, reservePlayers } = this.generateGroupedTeams(players));
        break;
      case 'manual':
        this.initializeManualPairing(dateId, players);
        return; // Don't create matches yet for manual pairing
    }

    const matches = this.createMatches(teams);

    const generatedTeamsData: GeneratedMatches = {
      dateId,
      algorithm,
      teams,
      matches,
      reservePlayers,
      autoGenerated: false // Manual generation
    };

    this.generatedMatches[dateId] = generatedTeamsData;

    // Save to backend for non-admin users to see
    this.saveTeamsToBackend(generatedTeamsData);
  }

  // Save generated teams to backend
  private saveTeamsToBackend(generatedTeamsData: GeneratedMatches) {
    const pollId = this.route.snapshot.paramMap.get('id');
    if (!pollId) return;

    console.log('Attempting to save teams to backend:', generatedTeamsData);
    this.pollService.saveGeneratedTeams(pollId, generatedTeamsData).subscribe({
      next: (response) => {
        console.log('âœ… Teams successfully saved to backend:', response);
      },
      error: (error) => {
        console.error('âŒ Failed to save teams to backend:', error);
      }
    });
  }

  // Algorithm 1: Random team generation
  private generateRandomTeams(players: Player[]): { teams: Team[], reservePlayers: Player[] } {
    const shuffled = [...players].sort(() => Math.random() - 0.5);
    const teams: Team[] = [];
    const reservePlayers: Player[] = []; // Always empty - no reserves

    // For random generation, we don't create fixed teams
    // Instead, we'll pass all players to createMatches to handle rotation
    // Create minimal teams just to pass the structure, actual matching happens in createMatches
    if (players.length >= 2) {
      teams.push(this.createTeam(shuffled[0], shuffled[1], 1));
      if (shuffled.length >= 4) {
        teams.push(this.createTeam(shuffled[2], shuffled[3], 2));
      }
      // Don't create more teams here - createMatches will handle all players
    }

    return { teams, reservePlayers };
  }

  // Algorithm 2: Balanced (Top vs Bottom)
  private generateBalancedTeams(players: Player[]): { teams: Team[], reservePlayers: Player[] } {
    const teams: Team[] = [];
    const reservePlayers: Player[] = []; // No reserves - include all players
    
    // Include ALL players, not just multiples of 4
    for (let i = 0; i < players.length - 1; i += 2) {
      if (i + 1 < players.length) {
        // Pair highest with lowest available seed
        const remainingPlayers = players.slice(i);
        const highSeed = remainingPlayers[0];
        const lowSeed = remainingPlayers[remainingPlayers.length - 1];
        
        teams.push(this.createTeam(highSeed, lowSeed, teams.length + 1));
        
        // Remove the paired players from consideration
        players.splice(players.indexOf(lowSeed), 1);
      }
    }

    return { teams, reservePlayers };
  }

  // Algorithm 3: Skill-Level Groups
  private generateGroupedTeams(players: Player[]): { teams: Team[], reservePlayers: Player[] } {
    const teams: Team[] = [];
    const reservePlayers: Player[] = []; // No reserves - include all players
    
    // Create teams from all players, pairing by skill level
    for (let i = 0; i < players.length - 1; i += 2) {
      if (i + 1 < players.length) {
        // Pair adjacent skill levels (1st+2nd, 3rd+4th, etc.)
        teams.push(this.createTeam(players[i], players[i + 1], teams.length + 1));
      }
    }
    
    // If odd number of players, pair the last player with the first team's second player
    // This ensures everyone plays

    return { teams, reservePlayers };
  }

  private createTeam(player1: Player, player2: Player, teamNumber: number): Team {
    return {
      id: `team-${teamNumber}`,
      player1,
      player2,
      averageSeed: (player1.seed + player2.seed) / 2
    };
  }

  private createMatches(teams: Team[]): Match[] {
    const matches: Match[] = [];
    
    if (teams.length < 2) {
      return matches;
    }

    // Support up to 4 matches - all players participate, no reserves
    if (teams.length >= 1) {
      // Get all individual players from teams
      const allPlayers: Player[] = [];
      teams.forEach(team => {
        allPlayers.push(team.player1, team.player2);
      });
      
      const totalPlayers = allPlayers.length;
      
      if (totalPlayers >= 4) {
        // For 4 players: Generate all possible unique combinations (up to 4 matches)
        if (totalPlayers === 4) {
          const [p1, p2, p3, p4] = allPlayers;
          
          // All possible team combinations for 4 players (3 unique + 1 repeat with role swap)
          const allCombinations = [
            { teamA: this.createTeam(p1, p2, 1), teamB: this.createTeam(p3, p4, 2) },
            { teamA: this.createTeam(p1, p3, 1), teamB: this.createTeam(p2, p4, 2) },
            { teamA: this.createTeam(p1, p4, 1), teamB: this.createTeam(p2, p3, 2) },
            { teamA: this.createTeam(p2, p4, 1), teamB: this.createTeam(p1, p3, 2) } // 4th match with different team roles
          ];
          
          allCombinations.forEach((combo, index) => {
            matches.push({
              id: `match-${index + 1}`,
              teamA: combo.teamA,
              teamB: combo.teamB
            });
          });
        } else {
          // For 5+ players: Create 4 matches ensuring ALL players participate
          const playerPool = [...allPlayers];
          const usedPlayers = new Set<string>();
          
          for (let matchNum = 1; matchNum <= 4; matchNum++) {
            // Prioritize players who haven't played much
            const availablePlayers = playerPool.filter(p => {
              const playCount = Array.from(usedPlayers).filter(id => id === p.id).length;
              return playCount < 2; // Each player can play up to 2 times across 4 matches
            });
            
            // If not enough available players, include all players
            const playersForMatch = availablePlayers.length >= 4 ? availablePlayers : playerPool;
            const shuffledPlayers = [...playersForMatch].sort(() => Math.random() - 0.5);
            
            if (shuffledPlayers.length >= 4) {
              const teamA = this.createTeam(shuffledPlayers[0], shuffledPlayers[1], 1);
              const teamB = this.createTeam(shuffledPlayers[2], shuffledPlayers[3], 2);
              
              // Track which players are used
              usedPlayers.add(shuffledPlayers[0].id);
              usedPlayers.add(shuffledPlayers[1].id);
              usedPlayers.add(shuffledPlayers[2].id);
              usedPlayers.add(shuffledPlayers[3].id);
              
              matches.push({
                id: `match-${matchNum}`,
                teamA,
                teamB
              });
            }
          }
        }
      }
    }

    return matches;
  }

  hasGeneratedMatches(dateId: string): boolean {
    const hasMatches = !!this.generatedMatches[dateId];
    console.log(`ðŸ” hasGeneratedMatches(${dateId}):`, hasMatches);
    return hasMatches;
  }

  getGeneratedMatches(dateId: string): GeneratedMatches | undefined {
    return this.generatedMatches[dateId];
  }

  // Manual pairing methods
  initializeManualPairing(dateId: string, players: Player[]) {
    this.manualPairingStates[dateId] = {
      availablePlayers: [...players],
      selectedPlayers: [],
      teams: [],
      reservePlayers: []
    };
  }

  getManualPairingState(dateId: string): ManualPairingState | undefined {
    return this.manualPairingStates[dateId];
  }

  isManualPairingMode(dateId: string): boolean {
    return this.selectedAlgorithms[dateId] === 'manual' && !!this.manualPairingStates[dateId];
  }

  selectPlayerForTeam(dateId: string, player: Player) {
    const state = this.manualPairingStates[dateId];
    if (!state) return;

    // Move player from available to selected
    state.availablePlayers = state.availablePlayers.filter(p => p.id !== player.id);
    state.selectedPlayers.push(player);

    // If we have 2 selected players, create a team
    if (state.selectedPlayers.length === 2) {
      this.createManualTeam(dateId);
    }
  }

  unselectPlayer(dateId: string, player: Player) {
    const state = this.manualPairingStates[dateId];
    if (!state) return;

    // Move player from selected back to available
    state.selectedPlayers = state.selectedPlayers.filter(p => p.id !== player.id);
    state.availablePlayers.push(player);
    // Sort by seed to maintain order
    state.availablePlayers.sort((a, b) => a.seed - b.seed);
  }

  createManualTeam(dateId: string) {
    const state = this.manualPairingStates[dateId];
    if (!state || state.selectedPlayers.length !== 2) return;

    const [player1, player2] = state.selectedPlayers;
    const team = this.createTeam(player1, player2, state.teams.length + 1);
    
    state.teams.push(team);
    state.selectedPlayers = [];
  }

  removeTeam(dateId: string, teamId: string) {
    const state = this.manualPairingStates[dateId];
    if (!state) return;

    const teamIndex = state.teams.findIndex(t => t.id === teamId);
    if (teamIndex === -1) return;

    const team = state.teams[teamIndex];
    
    // Move players back to available
    state.availablePlayers.push(team.player1, team.player2);
    state.availablePlayers.sort((a, b) => a.seed - b.seed);
    
    // Remove team
    state.teams.splice(teamIndex, 1);
    
    // Renumber remaining teams
    state.teams.forEach((team, index) => {
      team.id = `team-${index + 1}`;
    });
  }

  moveToReserve(dateId: string, player: Player) {
    const state = this.manualPairingStates[dateId];
    if (!state) return;

    // Remove from available and add to reserves
    state.availablePlayers = state.availablePlayers.filter(p => p.id !== player.id);
    state.reservePlayers.push(player);
  }

  moveFromReserve(dateId: string, player: Player) {
    const state = this.manualPairingStates[dateId];
    if (!state) return;

    // Remove from reserves and add to available
    state.reservePlayers = state.reservePlayers.filter(p => p.id !== player.id);
    state.availablePlayers.push(player);
    state.availablePlayers.sort((a, b) => a.seed - b.seed);
  }

  finalizeManualPairing(dateId: string) {
    const state = this.manualPairingStates[dateId];
    if (!state) return;

    // Move any remaining available players to reserves
    state.reservePlayers.push(...state.availablePlayers);
    state.availablePlayers = [];

    // Create matches from teams
    const matches = this.createMatches(state.teams);

    const generatedTeamsData = {
      dateId,
      algorithm: 'manual',
      teams: state.teams,
      matches,
      reservePlayers: state.reservePlayers
    };

    this.generatedMatches[dateId] = generatedTeamsData;

    // Clear manual pairing state
    delete this.manualPairingStates[dateId];

    // Save to backend
    this.saveTeamsToBackend(generatedTeamsData);
  }

  cancelManualPairing(dateId: string) {
    delete this.manualPairingStates[dateId];
    this.selectedAlgorithms[dateId] = '';
  }

  // Match removal methods
  removeMatch(dateId: string, matchId: string) {
    const generatedData = this.generatedMatches[dateId];
    if (!generatedData) return;

    // Find the match to remove
    const matchIndex = generatedData.matches.findIndex(m => m.id === matchId);
    if (matchIndex === -1) return;

    const match = generatedData.matches[matchIndex];
    const matchNumber = match.id.split('-')[1];
    
    // Open confirmation dialog
    const dialogRef = this.dialog.open(ConfirmDialogComponent, {
      width: '400px'
    });
    
    dialogRef.componentInstance.title = `Remove Match ${matchNumber}`;
    dialogRef.componentInstance.message = `Are you sure you want to remove Match ${matchNumber}? The 4 players will be moved to reserves.`;
    dialogRef.componentInstance.confirmText = 'Remove Match';

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        // Move players from the match back to reserves
        generatedData.reservePlayers.push(
          match.teamA.player1,
          match.teamA.player2,
          match.teamB.player1,
          match.teamB.player2
        );

        // Remove the match
        generatedData.matches.splice(matchIndex, 1);

        // Remove the teams from the teams array
        generatedData.teams = generatedData.teams.filter(
          team => team.id !== match.teamA.id && team.id !== match.teamB.id
        );

        // Renumber remaining matches
        generatedData.matches.forEach((match, index) => {
          match.id = `match-${index + 1}`;
        });

        // Save updated data to backend
        this.saveTeamsToBackend(generatedData);
      }
    });
  }

  forceRegenerateTeams(dateId: string) {
    // Open confirmation dialog
    const dialogRef = this.dialog.open(ConfirmDialogComponent, {
      width: '400px'
    });
    
    dialogRef.componentInstance.title = 'Force Regenerate Teams';
    dialogRef.componentInstance.message = 'This will clear existing teams and regenerate them with ALL current voters for this date. This ensures all players who voted are included. Continue?';
    dialogRef.componentInstance.confirmText = 'Force Regenerate';

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        console.log(`ðŸ”„ Force regenerating teams for ${dateId}`);
        
        // Get current voters (this will include Aileen G. Flores if she voted)
        const currentPlayers = this.getPlayersForDate(dateId);
        console.log(`ðŸ” Current voters for ${dateId}:`, currentPlayers.map(p => p.name));
        
        // Clear existing data completely
        delete this.generatedMatches[dateId];
        
        // Force auto-generation with current players
        if (currentPlayers.length >= 4) {
          this.autoGenerateTeamsForDate(dateId, currentPlayers);
          this.showSuccessMessage(`Teams regenerated with all ${currentPlayers.length} voters!`);
        } else {
          this.showErrorMessage(`Need at least 4 voters to generate teams (found ${currentPlayers.length})`);
        }
      }
    });
  }

  clearAllMatches(dateId: string) {
    const generatedData = this.generatedMatches[dateId];
    if (!generatedData) return;

    // Open confirmation dialog
    const dialogRef = this.dialog.open(ConfirmDialogComponent, {
      width: '400px'
    });
    
    dialogRef.componentInstance.title = 'Clear All Matches';
    dialogRef.componentInstance.message = 'Are you sure you want to clear all matches for this date? All players will be moved to reserves. This action cannot be undone.';
    dialogRef.componentInstance.confirmText = 'Clear All';

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        // Move all players to reserves
        generatedData.teams.forEach(team => {
          generatedData.reservePlayers.push(team.player1, team.player2);
        });

        // Clear teams and matches
        generatedData.teams = [];
        generatedData.matches = [];

        // Save updated data to backend
        this.saveTeamsToBackend(generatedData);
      }
    });
  }

  private showSuccessMessage(message: string) {
    this.snackBar.open(message, 'Close', {
      duration: 3000,
      panelClass: ['success-snackbar']
    });
  }

  private showErrorMessage(message: string) {
    this.snackBar.open(message, 'Close', {
      duration: 5000,
      panelClass: ['error-snackbar']
    });
  }

  private showInsufficientCoinsMessage(action: string = 'access poll results') {
    const cost = action === 'generate teams' ? this.coinService.getFeatureCost('TEAM_GENERATION') : this.pageCost;
    const message = `Insufficient coins to ${action}. Need ${cost} coin${cost > 1 ? 's' : ''}.`;
    this.snackBar.open(message, 'Purchase Coins', {
      duration: 8000,
      panelClass: ['warning-snackbar']
    }).onAction().subscribe(() => {
      this.openPurchaseModal();
    });
  }

  openPurchaseModal() {
    import('../../components/purchase-modal/purchase-modal.component').then(module => {
      this.dialog.open(module.PurchaseModalComponent, {
        width: '900px',
        maxWidth: '95vw',
        maxHeight: '90vh',
        data: { currentBalance: this.coinBalance }
      });
    });
  }

  // Auto-generation methods
  private checkForAutoGeneration() {
    if (!this.poll || !this.players.length) {
      console.log('ðŸ¤– Auto-generation skipped: missing poll or players');
      return;
    }

    console.log('ðŸ¤– Checking auto-generation for all dates...');
    
    // Check each date option for auto-generation opportunity
    this.poll.options.forEach(dateOption => {
      const players = this.getPlayersForDate(dateOption.id);
      const existingData = this.generatedMatches[dateOption.id];
      
      console.log(`ðŸ¤– Date ${dateOption.id}: ${players.length} players, existing data:`, existingData);
      console.log(`ðŸ” Players for ${dateOption.id}:`, players.map(p => p.name));
      
      // Auto-generate if 4+ players and no valid existing matches, or if existing matches are insufficient
      const hasValidMatches = existingData && existingData.matches && existingData.matches.length > 0;
      const expectedMatches = this.getExpectedMatchCount(players.length);
      const currentMatches = existingData?.matches?.length || 0;
      
      console.log(`ðŸ¤– Date ${dateOption.id}: hasValidMatches = ${hasValidMatches}, expected ${expectedMatches}, current ${currentMatches}`);
      
      // Always regenerate if there are more current players than what's in existing matches
      const existingPlayerCount = this.getPlayersInExistingMatches(dateOption.id);
      const needsRegeneration = players.length >= 4 && 
        (!hasValidMatches || currentMatches < expectedMatches || players.length > existingPlayerCount);
      
      if (needsRegeneration) {
        console.log(`ðŸ¤– Auto-generating teams for ${dateOption.id} with ${players.length} players (expected ${expectedMatches} matches, current ${currentMatches}, existing players: ${existingPlayerCount})`);
        this.autoGenerateTeamsForDate(dateOption.id, players);
      } else {
        console.log(`ðŸ¤– Skipping auto-generation for ${dateOption.id}: ${players.length} players, has ${currentMatches}/${expectedMatches} matches`);
      }
    });
  }

  private autoGenerateTeamsForDate(dateId: string, players: Player[]) {
    // For auto-generation, create matches directly from all players
    const matches = this.createMatchesFromAllPlayers(players);
    
    // Create dummy teams for structure (not actually used in display)
    const teams: Team[] = [];
    const reservePlayers: Player[] = []; // Always empty

    const generatedTeamsData: GeneratedMatches = {
      dateId,
      algorithm: 'random',
      teams,
      matches,
      reservePlayers,
      autoGenerated: true
    };

    this.generatedMatches[dateId] = generatedTeamsData;
    this.selectedAlgorithms[dateId] = 'random';

    // Save to backend
    this.saveTeamsToBackend(generatedTeamsData);
    console.log(`âœ… Auto-generated teams for ${dateId} with all ${players.length} players:`, generatedTeamsData);
  }

  isAutoGenerated(dateId: string): boolean {
    return this.generatedMatches[dateId]?.autoGenerated || false;
  }

  private getExpectedMatchCount(playerCount: number): number {
    if (playerCount >= 4) {
      // 4+ players: up to 4 matches with all players participating
      return 4;
    }
    return 0;
  }

  private getPlayersInExistingMatches(dateId: string): number {
    const existingData = this.generatedMatches[dateId];
    if (!existingData || !existingData.matches) {
      return 0;
    }
    
    const playerIds = new Set<string>();
    existingData.matches.forEach(match => {
      playerIds.add(match.teamA.player1.id);
      playerIds.add(match.teamA.player2.id);
      playerIds.add(match.teamB.player1.id);
      playerIds.add(match.teamB.player2.id);
    });
    
    return playerIds.size;
  }

  // Create matches directly from all players (for auto-generation)
  private createMatchesFromAllPlayers(allPlayers: Player[]): Match[] {
    const matches: Match[] = [];
    
    if (allPlayers.length < 4) {
      return matches;
    }

    console.log(`ðŸŽ¯ Creating matches from ${allPlayers.length} players:`, allPlayers.map(p => p.name));

    // Create 4 matches ensuring all players participate
    const playerPool = [...allPlayers];
    const playerUsageCount = new Map<string, number>();
    
    // Initialize usage count
    allPlayers.forEach(player => {
      playerUsageCount.set(player.id, 0);
    });

    for (let matchNum = 1; matchNum <= 4; matchNum++) {
      // Sort players by usage count (least used first) then shuffle among tied players
      const availablePlayers = playerPool
        .sort((a, b) => {
          const usageA = playerUsageCount.get(a.id) || 0;
          const usageB = playerUsageCount.get(b.id) || 0;
          if (usageA !== usageB) {
            return usageA - usageB; // Least used first
          }
          return Math.random() - 0.5; // Random among tied players
        });

      // Take first 4 available players
      if (availablePlayers.length >= 4) {
        const selectedPlayers = availablePlayers.slice(0, 4);
        
        // Create teams from selected players
        const teamA = this.createTeam(selectedPlayers[0], selectedPlayers[1], 1);
        const teamB = this.createTeam(selectedPlayers[2], selectedPlayers[3], 2);
        
        // Update usage count
        selectedPlayers.forEach(player => {
          const currentCount = playerUsageCount.get(player.id) || 0;
          playerUsageCount.set(player.id, currentCount + 1);
        });
        
        matches.push({
          id: `match-${matchNum}`,
          teamA,
          teamB
        });
        
        console.log(`âœ… Match ${matchNum}: ${selectedPlayers.map(p => p.name).join(', ')}`);
      }
    }

    console.log('ðŸŽ¯ Final player usage counts:');
    playerUsageCount.forEach((count, playerId) => {
      const player = allPlayers.find(p => p.id === playerId);
      console.log(`  ${player?.name}: ${count} matches`);
    });

    return matches;
  }
}
